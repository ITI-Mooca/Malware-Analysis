.586
 .model flat,stdcall
 .stack 4096

.data
	msg db 'Welcome to the Malware Analysis Course ~ Greets from EG|CERT!',0
	msg2 db 30 dup(0)
	db 50 dup(0)
	msg_lipsum_src db "Lorem Ipsum is simply dummy text of the printing and typesetting industry."
	db "Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley"
	db "of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap"
	db "into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of "
	db "Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus"
	db " PageMaker including versions of Lorem Ipsum.",0
	db 50 dup(0)
	msg_lipsum_dst db 700 dup(0)
.code

;https://stackoverflow.com/a/15347695
jumpIfEqual PROC var1:DWORD, var2:DWORD
    mov eax,var1
    cmp eax,var2
    jne loc_fail
    mov eax, 1
    jmp loc_success
    loc_fail:
	xor eax, eax
	loc_success:
    ret
jumpIfEqual ENDP

main PROC
 ; ===========================================
 ; =------------ 1. DATA MOVING INSTRUCTIONS ----
 ; =+> 1a) MOV
	mov eax, 42h
	mov ebx, 3h
	mov eax, ebx
	mov edx, dword ptr [msg]
	lea ebx, [msg]
	mov eax, [ebx]
	mov ecx, 5
	mov eax, dword ptr [ebx+ecx*2]
	
	nop
	nop
	nop
	
 ; =+> 1b) LEA
    lea edx, [msg]
	lea eax, [edx+2]
	lea edx, [eax+2]
	mov ecx, 4
	lea ebx, [ecx*2+3]
	
	nop
	nop
	nop
 
 ; =+> 1c) MOVZX and MOVSX
	mov cl, 5
	mov ebx, 5
	mov al, cl
	movzx eax, cl
	mov cl, 0E2h
	movsx eax, cl
 
	nop
	nop
	nop
 
 ; =+> 1d) XCHG
	mov eax, 2
	mov ebx, 5
	xchg eax, ebx
	xchg eax, ebx
	xchg ebx, eax
	
	nop
	nop
	nop
 
 ; =+> 1e) PUSH
	push 0
	push 1
	push eax
	push dword ptr [msg]
	push dword ptr [msg+16]
	
	nop
	nop
	nop
 
 ; =+> 1e) POP
	pop eax
	pop ebx
	lea edx, [msg]
	pop [edx]

	nop
	nop
	nop
 
 ; ===========================================
 ; =--------- 2. ARITHMETIC INSTRUCTIONS -------=

 ; =+> 2a) ADD, SUB, INC, DEC
	mov eax, 1
	add eax, 2
	mov ebx, 5
	add ebx, eax
	nop
	sub eax, 1
	sub ebx, eax
	nop
	inc eax
	inc ebx
	dec eax
	dec ebx
	mov eax, 1
	dec eax
	dec eax ; clear the ZF here from the debugger or use `test al, 1`
	inc eax
	nop
	nop
	nop
	
 ; =+> 2b) MUL, DIV
	mov al, 2
	mov bl, 3
	mul bl
	nop
	mov ax, 00001234h
	mov bx, 00004321h
	mul bx
	nop
	mov eax, 012341234h
	mov ebx, 043214321h
	mul ebx
	nop
	mov bl, 3
	mov ax, 012h
	div bl ; result should be "6"
	nop
	mov bx, 3
	mov dx, 0h
	mov ax, 013h
	div bx ; result should be "6" with Remainder of "1"
	nop
	mov eax, 05F2213h
	mov edx, 01234h
	mov ebx, 061075993h
	div ebx
	nop
	nop
	nop
	
 ; =+> 2c) iMUL, iDIV
	mov eax, 3
	mov ebx, 0FFh
	imul bl
	mov eax, 3
	mul bl
	nop
	mov ecx, 3
	mov ebx, 2
	imul ecx, ebx
	nop
	mov ecx, 3
	imul ebx, ecx, 2
	nop
	nop
	nop
	
 ; =+> 2d) CMP
	mov eax, 2
	mov ebx, 5
	cmp ebx, eax ; comparing two unequal operands
	je false1
	true1:
	mov eax, 1
	jmp default1
	false1:
	mov eax, 0
	default1:
	push eax
	nop
	mov eax, 4
	mov ebx, 4
	cmp eax, ebx ; here the 2 operands are equal
	je false2
	true2:
	mov eax, 1
	jmp default2
	false2:
	mov eax, 0
	default2:
	push eax
	nop
	mov eax, 8
	cmp eax, 8
	xor cl, cl
	sete cl	; setE 
	nop
	mov eax, 8
	cmp eax, 3
	xor dl, dl
	setne dl; setNE
	nop
	mov eax, 8
	cmp eax, 3
	xor bx, bx
	setne bl ; stacking setNE and setE
	sete bh
	sete cl
	sete dl
	nop
	nop
	nop
 
 ; ===========================================
 ; =--------- 3. LOGICAL AND SHIFTING INSTRUCTIONS -------=

 ; =+> 3a) AND, OR, XOR, NOT (+ Bitmasks)
	mov eax, 200
	mov ebx, 184
	and eax, ebx ;200 & 184 = 136 (0x88)
	nop
	mov eax, 200
	or eax, ebx ;200 | 184 = 248 (0xF8)
	nop
	mov eax, 200
	xor eax, ebx ;200 ^ 184 = 112 (0x70)
	xor eax, eax ;XOR anything with itself = 0
	xor ebx, ebx
	nop
	mov eax, 0C8h
	not al
	nop
	nop
	nop
	
 ; =+> 3b) SHR, SHL (+ SAR, SAL)
	mov eax, 0Ch
	shr eax, 2
	shl eax, 2
	shl eax, 2
	nop
	mov eax, 0F2000000h ;this number is negative (if we treat it as signed)
	shr eax, 1; now the number IS POSITIVE
	mov ebx, 0F2000000h; but here, the sign will be retained
	sar ebx, 1
	nop
	nop
	nop
	
 ; =+> 3c) ROR, ROL
	mov eax, 105 ;we want to do the rotations on a single byte (al) not on the whole dword (eax)
	ror al, 1; open the windows calc, and do the rotations on a single BYTE
	ror al, 1
	ror al, 1
	nop
	rol al, 1
	rol al, 2
	nop
	mov al, 011000101b
	and al, 000001111b
	mov ax, 01234h
	and ax, 00F0Fh
	nop
	nop
	nop
 
 
 
 
 ; ===========================================
 ; =--------- 4. CONTROL TRANSFER AND BRANCHING INSTRUCTIONS -------=

 ; =+> 4a) JMP
	mov eax, 5
	loc1:
	xchg ebx, ebx
	xchg ecx, ecx
	dec eax
	jmp loc2
	xor eax, eax
	loc2:
	cmp eax, 2
	jle loc3_exit
	jmp loc1
	mov eax, 01234h
	mov ebx, 05678h
	loc3_exit:
	jmp loc4
	int 3
	int 3
	int 3
	loc4:
	nop
	nop
	nop

 ; =+> 4b) CALL, RET
	push 1
	push 2
	call jumpIfEqual
	nop
	push loc_fake_ret
	ret
	add eax, 0213214h
	int 3
	aaa
	loc_fake_ret:
	nop
	nop
	nop

 ; =+> 4c) JMPcc
	mov eax, 1
	cmp eax, 15
	je loc_jcc_1
	jmp loc_jcc_2
	loc_jcc_1:
	int 3
	loc_jcc_2:
	cmp eax, 15
	jne loc_jcc_3
	int 3
	loc_jcc_3:
	xor eax, eax
	mov ecx, 1
	dec ecx
	jecxz loc_jcc_4
	int 3
	loc_jcc_4:
	mov eax, 01234h
	sub eax, 05678h
	jle loc_jcc_5
	aaa
	sar eax, 0Fh
	loc_jcc_5:
	nop
	nop
	nop

 ; =+> 4d) LOOP, LOOPcc
	mov edx, 012345678h
	mov eax, 0
	mov ecx, 8
	loc_loop_1:
	inc eax
	dec edx
	loop loc_loop_1
	nop
	mov edx, 5
	mov eax, 0
	mov ecx, 8
	loc_loop_2:
	inc eax
	dec edx
	cmp edx, 2
	loopne loc_loop_2
	nop
	nop
	nop

 
 
 ; ===========================================
 ; =--------- 5. STRING OPERATIONS INSTRUCTIONS -------=

 ; =+> 5a) MOVS
	lea esi, [msg+4]
	lea edi, [msg2]
	movsb
	movsb
	movsb
	movsw
	movsd
	nop
	nop
	nop
	
 ; =+> 5b) SCAS
	mov byte ptr [edi], 041h
	mov al, 041h
	scasb
	je loc_scas_1
	mov eax, 1234h
	sub eax, ebx
	loc_scas_1:
	nop
	mov byte ptr [edi], 041h
	mov al, 048h
	scasb
	je loc_scas_2
	jne loc_scas_3
	loc_scas_2:
	mov eax, 1234h
	sub eax, ebx
	loc_scas_3:
	nop
	nop
	nop
	
 ; =+> 5c) STOS
	mov al, 41h
	stosb
	mov al, 48h
	stosb
	mov eax, 2144414dh
	stosd
	nop
	nop
	nop

 ; =+> 5d) REP prefix (+ REPcc variants)
	lea esi, [msg_lipsum_src]
	lea edi, [msg_lipsum_dst]
	mov cl, 5
	rep movsb ;copying the first 5 bytes only
	nop
	lea esi, [msg_lipsum_src]
	lea edi, [msg_lipsum_dst]
	mov ecx, 575 ;our string's length (we can get the strlen using scasb to search for the null-terminator)
	rep movsb
	nop
	nop
	nop

 
 ; ===========================================
 ; =--------- 6. MISCELLANEOUS INSTRUCTIONS -------=

 ; =+> 6a) NOP
	xchg eax, eax
	xchg ebx, ebx
	nop

 ; =+> 6b) CPUID
	mov eax, 080000002h
	cpuid
	mov eax, 080000003h
	cpuid
	mov eax, 080000004h
	cpuid
	nop
	nop
	nop
	int 3

	ret
main ENDP
END main




 